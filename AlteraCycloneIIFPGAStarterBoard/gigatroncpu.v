/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

// octal D-type flip-flop with clear
module \74273  (
  input CP,
  input \~MR ,
  input D0,
  input D1,
  input D2,
  input D3,
  input D4,
  input D5,
  input D6,
  input D7,
  input VCC,
  input GND,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output Q4,
  output Q5,
  output Q6,
  output Q7
);
  wire s0;
  assign s0 = ~ \~MR ;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( D1 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q1 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( D2 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q2 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( D3 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q3 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( D0 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q0 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( D4 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q4 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i5 (
    .Set( 1'b0 ),
    .D( D5 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q5 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i6 (
    .Set( 1'b0 ),
    .D( D6 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q6 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i7 (
    .Set( 1'b0 ),
    .D( D7 ),
    .C( CP ),
    .Clr( s0 ),
    .Q( Q7 )
  );
endmodule

module Demux2
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel,
    input in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


// dual 2-line to 4-line decoder/demultiplexer
module \74139  (
  input \1A ,
  input \1B ,
  input \~1G ,
  input \2A ,
  input \2B ,
  input \~2G ,
  input VCC,
  input GND,
  output \~1Y0 ,
  output \~1Y1 ,
  output \~1Y2 ,
  output \~1Y3 ,
  output \~2Y0 ,
  output \~2Y1 ,
  output \~2Y2 ,
  output \~2Y3 
);
  wire [1:0] s0;
  wire [1:0] s1;
  assign s0[0] = \1A ;
  assign s0[1] = \1B ;
  assign s1[0] = \2A ;
  assign s1[1] = \2B ;
  Demux2 #(
    .Default(1)
  )
  Demux2_i0 (
    .sel( s0 ),
    .in( \~1G  ),
    .out_0( \~1Y0  ),
    .out_1( \~1Y1  ),
    .out_2( \~1Y2  ),
    .out_3( \~1Y3  )
  );
  Demux2 #(
    .Default(1)
  )
  Demux2_i1 (
    .sel( s1 ),
    .in( \~2G  ),
    .out_0( \~2Y0  ),
    .out_1( \~2Y1  ),
    .out_2( \~2Y2  ),
    .out_3( \~2Y3  )
  );
endmodule

module Demux3
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel,
    input in
);
    assign out_0 = (sel == 3'h0)? in : Default;
    assign out_1 = (sel == 3'h1)? in : Default;
    assign out_2 = (sel == 3'h2)? in : Default;
    assign out_3 = (sel == 3'h3)? in : Default;
    assign out_4 = (sel == 3'h4)? in : Default;
    assign out_5 = (sel == 3'h5)? in : Default;
    assign out_6 = (sel == 3'h6)? in : Default;
    assign out_7 = (sel == 3'h7)? in : Default;
endmodule


// 3-line to 8-line decoder/demultiplexer, inverted out
module \74138ndelay  (
  input A,
  input B,
  input C,
  input G,
  input \~GB ,
  input \~GA ,
  input VCC,
  input GND,
  output \~Y0 ,
  output \~Y1 ,
  output \~Y2 ,
  output \~Y3 ,
  output \~Y4 ,
  output \~Y5 ,
  output \~Y6 ,
  output \~Y7 
);
  wire [2:0] s0;
  wire s1;
  assign s0[0] = A;
  assign s0[1] = B;
  assign s0[2] = C;
  assign s1 = ~ (G & ~ \~GB  & ~ \~GA );
  Demux3 #(
    .Default(1)
  )
  Demux3_i0 (
    .sel( s0 ),
    .in( s1 ),
    .out_0( \~Y0  ),
    .out_1( \~Y1  ),
    .out_2( \~Y2  ),
    .out_3( \~Y3  ),
    .out_4( \~Y4  ),
    .out_5( \~Y5  ),
    .out_6( \~Y6  ),
    .out_7( \~Y7  )
  );
endmodule

module DriverInv
(
    input in,
    input sel,
    output out
);
    assign out = (sel == 1'b0)? in : 1'bz;
endmodule

// octal 3-state buffer/line driver/line receiver
module \74244fixed  (
  input \1A1 ,
  input \1A2 ,
  input \1A3 ,
  input \1A4 ,
  input \~1G ,
  input \2A1 ,
  input \2A2 ,
  input \2A3 ,
  input \2A4 ,
  input \~2G ,
  input VCC,
  input GND,
  output \1Y1 ,
  output \1Y2 ,
  output \1Y3 ,
  output \1Y4 ,
  output \2Y1 ,
  output \2Y2 ,
  output \2Y3 ,
  output \2Y4 
);
  DriverInv DriverInv_i0 (
    .in( \1A1  ),
    .sel( \~1G  ),
    .out( \1Y1  )
  );
  DriverInv DriverInv_i1 (
    .in( \1A2  ),
    .sel( \~1G  ),
    .out( \1Y2  )
  );
  DriverInv DriverInv_i2 (
    .in( \1A3  ),
    .sel( \~1G  ),
    .out( \1Y3  )
  );
  DriverInv DriverInv_i3 (
    .in( \1A4  ),
    .sel( \~1G  ),
    .out( \1Y4  )
  );
  DriverInv DriverInv_i4 (
    .in( \2A1  ),
    .sel( \~2G  ),
    .out( \2Y1  )
  );
  DriverInv DriverInv_i5 (
    .in( \2A2  ),
    .sel( \~2G  ),
    .out( \2Y2  )
  );
  DriverInv DriverInv_i6 (
    .in( \2A3  ),
    .sel( \~2G  ),
    .out( \2Y3  )
  );
  DriverInv DriverInv_i7 (
    .in( \2A4  ),
    .sel( \~2G  ),
    .out( \2Y4  )
  );
endmodule

// hex inverter, Schmitt trigger
module \7414  (
  input \1A ,
  input \2A ,
  input \3A ,
  input \4A ,
  input \5A ,
  input \6A ,
  input VCC,
  input GND,
  output \1Y ,
  output \2Y ,
  output \3Y ,
  output \4Y ,
  output \5Y ,
  output \6Y 
);
  assign \1Y  = ~ \1A ;
  assign \2Y  = ~ \2A ;
  assign \3Y  = ~ \3A ;
  assign \4Y  = ~ \4A ;
  assign \5Y  = ~ \5A ;
  assign \6Y  = ~ \6A ;
endmodule

// quad 2-input OR gate
module \7432  (
  input \1A ,
  input \1B ,
  input \2A ,
  input \2B ,
  input \3B ,
  input \3A ,
  input \4A ,
  input \4B ,
  input VCC,
  input GND,
  output \1Y ,
  output \2Y ,
  output \3Y ,
  output \4Y 
);
  assign \1Y  = (\1A  | \1B );
  assign \2Y  = (\2A  | \2B );
  assign \3Y  = (\3A  | \3B );
  assign \4Y  = (\4A  | \4B );
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_D_FF_AS_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input Set,
   input [(Bits-1):0] D,
   input C,
   input Clr,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= {Bits{1'b1}};
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



// hex synchronous counter, async clear
module \74161  (
  input \~LD ,
  input \~CLR ,
  input CLK,
  input ENT,
  input ENP,
  input A,
  input B,
  input C,
  input D,
  input VCC,
  input GND,
  output RCO,
  output QA,
  output QB,
  output QC,
  output QD
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire s2;
  wire s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire s7;
  assign s3 = (ENP & ENT);
  assign s5[0] = A;
  assign s5[1] = B;
  assign s5[2] = C;
  assign s5[3] = D;
  assign s7 = ~ \~CLR ;
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( s3 ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s4 )
  );
  assign RCO = (s2 & ENT);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( \~LD  ),
    .in_0( s5 ),
    .in_1( s4 ),
    .out( s6 )
  );
  DIG_D_FF_AS_Nbit #(
    .Bits(4),
    .Default(0)
  )
  DIG_D_FF_AS_Nbit_i2 (
    .Set( 1'b0 ),
    .D( s6 ),
    .C( CLK ),
    .Clr( s7 ),
    .Q( s0 )
  );
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i3 (
    .a( s0 ),
    .b( 4'b1 ),
    .c_i( 1'b0 ),
    .s( s1 ),
    .c_o( s2 )
  );
  assign QA = s0[0];
  assign QB = s0[1];
  assign QC = s0[2];
  assign QD = s0[3];
endmodule

module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


// dual 4-line to 1-line data selectors/multiplexers
module \74153  (
  input A,
  input B,
  input \2G ,
  input \2C0 ,
  input \2C1 ,
  input \2C2 ,
  input \2C3 ,
  input \1G ,
  input \1C0 ,
  input \1C1 ,
  input \1C2 ,
  input \1C3 ,
  input VCC,
  input GND,
  output \2Y ,
  output \1Y 
);
  wire [1:0] s0;
  wire s1;
  wire s2;
  assign s0[0] = A;
  assign s0[1] = B;
  Mux_4x1 Mux_4x1_i0 (
    .sel( s0 ),
    .in_0( \2C0  ),
    .in_1( \2C1  ),
    .in_2( \2C2  ),
    .in_3( \2C3  ),
    .out( s1 )
  );
  Mux_4x1 Mux_4x1_i1 (
    .sel( s0 ),
    .in_0( \1C0  ),
    .in_1( \1C1  ),
    .in_2( \1C2  ),
    .in_3( \1C3  ),
    .out( s2 )
  );
  assign \2Y  = (~ \2G  & s1);
  assign \1Y  = (~ \1G  & s2);
endmodule

// 4-bit binary full adder, alternative pinning
module \74283  (
  input C0,
  input B1,
  input B2,
  input B3,
  input B4,
  input A1,
  input A2,
  input A3,
  input A4,
  input VCC,
  input GND,
  output S1,
  output S2,
  output S3,
  output S4,
  output C4
);
  wire [3:0] s0;
  wire [3:0] s5;
  wire [3:0] s6;
  assign s5[0] = B1;
  assign s5[1] = B2;
  assign s5[2] = B3;
  assign s5[3] = B4;
  assign s0[0] = A1;
  assign s0[1] = A2;
  assign s0[2] = A3;
  assign s0[3] = A4;
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i0 (
    .a( s0 ),
    .b( s5 ),
    .c_i( C0 ),
    .s( s6 ),
    .c_o( C4 )
  );
  assign S1 = s6[0];
  assign S2 = s6[1];
  assign S3 = s6[2];
  assign S4 = s6[3];
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


// Octal D Flip-Flop with enable
module \74377  (
  input D0,
  input VCC,
  input GND,
  input D1,
  input D2,
  input D3,
  input \~E ,
  input D4,
  input D5,
  input D6,
  input D7,
  input CLK,
  output Q0,
  output Q1,
  output Q2,
  output Q3,
  output Q4,
  output Q5,
  output Q6,
  output Q7
);
  wire s0;
  wire s1;
  wire Q0_temp;
  wire s2;
  wire Q1_temp;
  wire s3;
  wire Q2_temp;
  wire s4;
  wire Q3_temp;
  wire s5;
  wire Q4_temp;
  wire s6;
  wire Q5_temp;
  wire s7;
  wire Q6_temp;
  wire s8;
  wire Q7_temp;
  assign s1 = ~ \~E ;
  assign s0 = ((Q0_temp & \~E ) | (D0 & s1));
  assign s2 = ((Q1_temp & \~E ) | (D1 & s1));
  assign s3 = ((Q2_temp & \~E ) | (D2 & s1));
  assign s4 = ((Q3_temp & \~E ) | (D3 & s1));
  assign s5 = ((Q4_temp & \~E ) | (D4 & s1));
  assign s6 = ((Q5_temp & \~E ) | (D5 & s1));
  assign s7 = ((Q6_temp & \~E ) | (D6 & s1));
  assign s8 = ((Q7_temp & \~E ) | (D7 & s1));
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( s0 ),
    .C( CLK ),
    .Q( Q0_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s2 ),
    .C( CLK ),
    .Q( Q1_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s3 ),
    .C( CLK ),
    .Q( Q2_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i3 (
    .D( s4 ),
    .C( CLK ),
    .Q( Q3_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s5 ),
    .C( CLK ),
    .Q( Q4_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i5 (
    .D( s6 ),
    .C( CLK ),
    .Q( Q5_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i6 (
    .D( s7 ),
    .C( CLK ),
    .Q( Q6_temp )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i7 (
    .D( s8 ),
    .C( CLK ),
    .Q( Q7_temp )
  );
  assign Q0 = Q0_temp;
  assign Q1 = Q1_temp;
  assign Q2 = Q2_temp;
  assign Q3 = Q3_temp;
  assign Q4 = Q4_temp;
  assign Q5 = Q5_temp;
  assign Q6 = Q6_temp;
  assign Q7 = Q7_temp;
endmodule

// quad 2-line to 1-line data selectors/multiplexers
module \74157  (
  input S, // select
  input A1,
  input A2,
  input A3,
  input A4,
  input B1,
  input B2,
  input B3,
  input B4,
  input G, // strobe
  input VCC,
  input GND,
  output Y1,
  output Y2,
  output Y3,
  output Y4
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire [3:0] s2;
  wire [3:0] s3;
  assign s1[0] = B1;
  assign s1[1] = B2;
  assign s1[2] = B3;
  assign s1[3] = B4;
  assign s0[0] = A1;
  assign s0[1] = A2;
  assign s0[2] = A3;
  assign s0[3] = A4;
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( S ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( G ),
    .in_0( s2 ),
    .in_1( 4'b0 ),
    .out( s3 )
  );
  assign Y1 = s3[0];
  assign Y2 = s3[1];
  assign Y3 = s3[2];
  assign Y4 = s3[3];
endmodule
module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DriverInvBus#(
    parameter Bits = 2
)
(
    input [(Bits-1):0] in,
    input sel,
    output [(Bits-1):0] out
);
    assign out = (sel == 1'b0)? in : {Bits{1'bz}};
endmodule

// 8-Bit Shift Registers with 3-State Output Registers
module \74595  (
  input SER,
  input SCLK,
  input RCLK,
  input \~OE ,
  input \~CLR ,
  input VCC,
  input GND,
  output Q_A,
  output Q_B,
  output Q_C,
  output Q_D,
  output Q_E,
  output Q_F,
  output Q_G,
  output Q_H,
  output \Q_H' 
);
  wire \Q_H'_temp ;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire [7:0] s8;
  wire [7:0] s9;
  wire [7:0] s10;
  assign s0 = ~ \~CLR ;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( SER ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s1 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( s1 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s2 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s2 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s3 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( s3 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s4 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( s4 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s5 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i5 (
    .Set( 1'b0 ),
    .D( s5 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s6 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i6 (
    .Set( 1'b0 ),
    .D( s6 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( s7 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i7 (
    .Set( 1'b0 ),
    .D( s7 ),
    .C( SCLK ),
    .Clr( s0 ),
    .Q( \Q_H'_temp  )
  );
  assign s8[0] = s1;
  assign s8[1] = s2;
  assign s8[2] = s3;
  assign s8[3] = s4;
  assign s8[4] = s5;
  assign s8[5] = s6;
  assign s8[6] = s7;
  assign s8[7] = \Q_H'_temp ;
  DIG_D_FF_Nbit #(
    .Bits(8),
    .Default(0)
  )
  DIG_D_FF_Nbit_i8 (
    .D( s8 ),
    .C( RCLK ),
    .Q( s9 )
  );
  DriverInvBus #(
    .Bits(8)
  )
  DriverInvBus_i9 (
    .in( s9 ),
    .sel( \~OE  ),
    .out( s10 )
  );
  assign Q_A = s10[0];
  assign Q_B = s10[1];
  assign Q_C = s10[2];
  assign Q_D = s10[3];
  assign Q_E = s10[4];
  assign Q_F = s10[5];
  assign Q_G = s10[6];
  assign Q_H = s10[7];
  assign \Q_H'  = \Q_H'_temp ;
endmodule

module gigatroncpu (
  input CLK1,
  input CLK2,
  input \~RESET ,
  input [15:0] ROMDATA, // Data in ROM. This is the next instruction executed.
  input [7:0] SRAMDATAREAD, // Data read from SRAM.
  input SER_DATA, // Sub-D pol 9, pin 2 of Famiclone game controller
  output [15:0] ROMAddress, // Current address in ROM. Next instruction is fetched from this address.
  output [7:0] EXOUT, // Bit 0 to 3 are LEDs. Bit 4 to 7 is Audio out.
  output [15:0] SRAMAddress, // SRAM address. A15 is not used in original Gigatron TTL schematic.
  output [7:0] SRAMDATAWRITE, // Data written to SRAM.
  output \~OE_SRAM , // Control line for reading SRAM.
  output \~WE_SRAM , // Control line for writing SRAM.
  output [3:0] VGA_R, // VGA red output.
  output [3:0] VGA_G, // VGA green output.
  output [3:0] VGA_B, // VGA blue output.
  output VGA_HS,
  output VGA_VS,
  output SER_PULSE, // Sub-D pol 9, pin 4 of Famiclone game controller
  output SER_LATCH, // Sub-D pol 9, pin 3 of Famiclone game controller
  output [7:0] RegIR, // Instruction Register Value
  output [7:0] RegDR, // Data Register Value
  output [7:0] RegAccu, // Accumulator Register Value
  output [7:0] RegX, // X Register Value
  output [7:0] RegY, // Y Register Value
  output [7:0] RegOUT, // OUT Register Value
  output [7:0] BUSValue, // Value on internal BUS.
  output [7:0] ALUValue, // Current value calculated by ALU.
  output [7:0] \Input , // Input data read from gamepad (for debugging).
  output \~IE  // Control line for reading data from gamepad (for debugging).

);
  wire BUS0;
  wire BUS1;
  wire BUS2;
  wire BUS3;
  wire PL;
  wire PC3;
  wire PC2;
  wire PC1;
  wire PC0;
  wire s0;
  wire BUS4;
  wire BUS5;
  wire BUS6;
  wire BUS7;
  wire PC7;
  wire PC6;
  wire PC5;
  wire PC4;
  wire s1;
  wire Y0;
  wire Y1;
  wire Y2;
  wire Y3;
  wire PH;
  wire PC11;
  wire PC10;
  wire PC9;
  wire PC8;
  wire s2;
  wire Y4;
  wire Y5;
  wire Y6;
  wire Y7;
  wire PC15;
  wire PC14;
  wire PC13;
  wire PC12;
  wire [7:0] BUSValue_temp;
  wire IR7;
  wire DQ7;
  wire DQ4;
  wire IR4;
  wire IR3;
  wire DQ3;
  wire DQ0;
  wire IR0;
  wire IR1;
  wire DQ1;
  wire DQ2;
  wire IR2;
  wire IR5;
  wire DQ5;
  wire DQ6;
  wire IR6;
  wire D7;
  wire DQ15;
  wire DQ13;
  wire D5;
  wire D3;
  wire DQ11;
  wire DQ9;
  wire D1;
  wire D0;
  wire DQ8;
  wire DQ10;
  wire D2;
  wire D4;
  wire DQ12;
  wire DQ14;
  wire D6;
  wire AR3;
  wire AR2;
  wire AR1;
  wire AR0;
  wire s3;
  wire s4;
  wire AC3;
  wire AL;
  wire ALU1;
  wire s5;
  wire s6;
  wire ALU0;
  wire s7;
  wire s8;
  wire s9;
  wire ALU3;
  wire ALU2;
  wire s10;
  wire s11;
  wire ALU5;
  wire s12;
  wire s13;
  wire ALU4;
  wire s14;
  wire s15;
  wire CO;
  wire ALU7;
  wire s16;
  wire s17;
  wire ALU6;
  wire s18;
  wire s19;
  wire AC2;
  wire AC1;
  wire AC0;
  wire AC4;
  wire AC5;
  wire AC6;
  wire AC7;
  wire \~AR0 ;
  wire \~AR1 ;
  wire \~AR2 ;
  wire INV_B_OUT;
  wire INV_B_IN;
  wire s20;
  wire INV_A_IN;
  wire \~AR3 ;
  wire INV_C_IN;
  wire INV_C_OUT;
  wire \~AL ;
  wire JUMP_INSN;
  wire \~WE_SRAM_temp ;
  wire OL_INSN;
  wire \~OL ;
  wire \~LD ;
  wire LD_INSN;
  wire s21;
  wire \~DE ;
  wire \~OE_SRAM_temp ;
  wire \~AE ;
  wire \~IE_temp ;
  wire \~XL ;
  wire s22;
  wire X7;
  wire X6;
  wire X5;
  wire X4;
  wire X3;
  wire X2;
  wire X1;
  wire X0;
  wire \~YL ;
  wire OUT3;
  wire OUT2;
  wire OUT1;
  wire OUT0;
  wire OUT4;
  wire OUT5;
  wire SER_PULSE_temp;
  wire SER_LATCH_temp;
  wire EL;
  wire SRAM_A4;
  wire SRAM_A5;
  wire SRAM_A6;
  wire SRAM_A7;
  wire SRAM_A1;
  wire SRAM_A2;
  wire SRAM_A3;
  wire SRAM_A0;
  wire SRAM_A13;
  wire SRAM_A14;
  wire SRAM_A11;
  wire SRAM_A9;
  wire EH;
  wire SRAM_A8;
  wire SRAM_A15;
  wire SRAM_A10;
  wire SRAM_A12;
  wire EXOUT0;
  wire EXOUT1;
  wire EXOUT2;
  wire EXOUT3;
  wire EXOUT4;
  wire EXOUT5;
  wire EXOUT6;
  wire EXOUT7;
  wire IEBUS1;
  wire IEBUS2;
  wire IEBUS3;
  wire IEBUS4;
  wire IEBUS5;
  wire IEBUS6;
  wire IEBUS7;
  wire IEBUS0;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire s33;
  wire DEBUS0;
  wire DEBUS1;
  wire DEBUS2;
  wire DEBUS3;
  wire DEBUS4;
  wire DEBUS5;
  wire DEBUS6;
  wire DEBUS7;
  wire [7:0] DEBUS;
  wire [7:0] s34;
  wire [7:0] s35;
  wire [7:0] Input_temp;
  wire [7:0] s36;
  wire AEBUS0;
  wire AEBUS1;
  wire AEBUS2;
  wire AEBUS3;
  wire AEBUS4;
  wire AEBUS5;
  wire AEBUS6;
  wire AEBUS7;
  wire [7:0] AEBUS;
  wire [7:0] s37;
  wire [7:0] s38;
  wire [7:0] s39;
  wire [7:0] s40;
  assign DQ0 = ROMDATA[0];
  assign DQ1 = ROMDATA[1];
  assign DQ2 = ROMDATA[2];
  assign DQ3 = ROMDATA[3];
  assign DQ4 = ROMDATA[4];
  assign DQ5 = ROMDATA[5];
  assign DQ6 = ROMDATA[6];
  assign DQ7 = ROMDATA[7];
  assign DQ8 = ROMDATA[8];
  assign DQ9 = ROMDATA[9];
  assign DQ10 = ROMDATA[10];
  assign DQ11 = ROMDATA[11];
  assign DQ12 = ROMDATA[12];
  assign DQ13 = ROMDATA[13];
  assign DQ14 = ROMDATA[14];
  assign DQ15 = ROMDATA[15];
  // Instruction Register IR
  \74273  \74273_i0 (
    .\~MR ( 1'b1 ),
    .D0( DQ7 ),
    .D1( DQ4 ),
    .D2( DQ3 ),
    .D3( DQ0 ),
    .GND( 1'b0 ),
    .CP( CLK1 ),
    .D4( DQ1 ),
    .D5( DQ2 ),
    .D6( DQ5 ),
    .D7( DQ6 ),
    .VCC( 1'b1 ),
    .Q0( IR7 ),
    .Q1( IR4 ),
    .Q2( IR3 ),
    .Q3( IR0 ),
    .Q4( IR1 ),
    .Q5( IR2 ),
    .Q6( IR5 ),
    .Q7( IR6 )
  );
  // Data Register DR
  \74273  \74273_i1 (
    .\~MR ( 1'b1 ),
    .D0( DQ15 ),
    .D1( DQ13 ),
    .D2( DQ11 ),
    .D3( DQ9 ),
    .GND( 1'b0 ),
    .CP( CLK1 ),
    .D4( DQ8 ),
    .D5( DQ10 ),
    .D6( DQ12 ),
    .D7( DQ14 ),
    .VCC( 1'b1 ),
    .Q0( D7 ),
    .Q1( D5 ),
    .Q2( D3 ),
    .Q3( D1 ),
    .Q4( D0 ),
    .Q5( D2 ),
    .Q6( D4 ),
    .Q7( D6 )
  );
  assign RegIR[0] = IR0;
  assign RegIR[1] = IR1;
  assign RegIR[2] = IR2;
  assign RegIR[3] = IR3;
  assign RegIR[4] = IR4;
  assign RegIR[5] = IR5;
  assign RegIR[6] = IR6;
  assign RegIR[7] = IR7;
  assign RegDR[0] = D0;
  assign RegDR[1] = D1;
  assign RegDR[2] = D2;
  assign RegDR[3] = D3;
  assign RegDR[4] = D4;
  assign RegDR[5] = D5;
  assign RegDR[6] = D6;
  assign RegDR[7] = D7;
  // Bus access decoder and 16-Bit jump (JMP) decoder
  \74139  \74139_i2 (
    .\~1G ( 1'b0 ),
    .\1A ( IR0 ),
    .\1B ( IR1 ),
    .GND( 1'b0 ),
    .\2B ( IR2 ),
    .\2A ( IR3 ),
    .\~2G ( IR4 ),
    .VCC( 1'b1 ),
    .\~1Y0 ( \~DE  ),
    .\~1Y1 ( \~OE_SRAM_temp  ),
    .\~1Y2 ( \~AE  ),
    .\~1Y3 ( \~IE_temp  ),
    .\~2Y0 ( s21 )
  );
  // Operation Decoder
  \74138ndelay  \74138ndelay_i3 (
    .A( IR5 ),
    .B( IR6 ),
    .C( IR7 ),
    .\~GA ( 1'b0 ),
    .\~GB ( 1'b0 ),
    .G( 1'b1 ),
    .GND( 1'b0 ),
    .VCC( 1'b1 ),
    .\~Y7 ( JUMP_INSN ),
    .\~Y6 ( INV_B_IN ),
    .\~Y5 ( s28 ),
    .\~Y4 ( s26 ),
    .\~Y3 ( s27 ),
    .\~Y2 ( s25 ),
    .\~Y1 ( s24 ),
    .\~Y0 ( s23 )
  );
  assign \~AR3  = (s23 & s24 & s25 & s26);
  assign \~AR2  = (s23 & s25 & s27 & s26 & JUMP_INSN);
  assign \~AR1  = (s25 & s27 & s28);
  assign \~AR0  = (s28 & JUMP_INSN);
  assign \~AL  = (IR7 & JUMP_INSN);
  assign s34[0] = \~DE ;
  assign s34[1] = \~DE ;
  assign s34[2] = \~DE ;
  assign s34[3] = \~DE ;
  assign s34[4] = \~DE ;
  assign s34[5] = \~DE ;
  assign s34[6] = \~DE ;
  assign s34[7] = \~DE ;
  assign s36[0] = \~IE_temp ;
  assign s36[1] = \~IE_temp ;
  assign s36[2] = \~IE_temp ;
  assign s36[3] = \~IE_temp ;
  assign s36[4] = \~IE_temp ;
  assign s36[5] = \~IE_temp ;
  assign s36[6] = \~IE_temp ;
  assign s36[7] = \~IE_temp ;
  assign s37[0] = \~AE ;
  assign s37[1] = \~AE ;
  assign s37[2] = \~AE ;
  assign s37[3] = \~AE ;
  assign s37[4] = \~AE ;
  assign s37[5] = \~AE ;
  assign s37[6] = \~AE ;
  assign s37[7] = \~AE ;
  assign s38[0] = \~OE_SRAM_temp ;
  assign s38[1] = \~OE_SRAM_temp ;
  assign s38[2] = \~OE_SRAM_temp ;
  assign s38[3] = \~OE_SRAM_temp ;
  assign s38[4] = \~OE_SRAM_temp ;
  assign s38[5] = \~OE_SRAM_temp ;
  assign s38[6] = \~OE_SRAM_temp ;
  assign s38[7] = \~OE_SRAM_temp ;
  // Mode Decoder
  \74138ndelay  \74138ndelay_i4 (
    .A( IR2 ),
    .B( IR3 ),
    .C( IR4 ),
    .\~GA ( 1'b0 ),
    .\~GB ( 1'b0 ),
    .G( JUMP_INSN ),
    .GND( 1'b0 ),
    .VCC( 1'b1 ),
    .\~Y7 ( INV_A_IN ),
    .\~Y6 ( s32 ),
    .\~Y5 ( \~YL  ),
    .\~Y4 ( \~XL  ),
    .\~Y3 ( s30 ),
    .\~Y2 ( s29 ),
    .\~Y1 ( s31 ),
    .\~Y0 ( s33 )
  );
  // Non-inverting tri-state buffer
  \74244fixed  \74244fixed_i5 (
    .\~1G ( \~DE  ),
    .\1A1 ( D6 ),
    .\1A2 ( D7 ),
    .\1A3 ( D5 ),
    .\1A4 ( D3 ),
    .GND( 1'b0 ),
    .\2A1 ( D1 ),
    .\2A2 ( D0 ),
    .\2A3 ( D2 ),
    .\2A4 ( D4 ),
    .\~2G ( \~DE  ),
    .VCC( 1'b1 ),
    .\2Y4 ( DEBUS4 ),
    .\2Y3 ( DEBUS2 ),
    .\2Y2 ( DEBUS0 ),
    .\2Y1 ( DEBUS1 ),
    .\1Y4 ( DEBUS3 ),
    .\1Y3 ( DEBUS5 ),
    .\1Y2 ( DEBUS7 ),
    .\1Y1 ( DEBUS6 )
  );
  // Buffer/Inverter 1
  \7414  \7414_i6 (
    .\1A ( \~AR0  ),
    .\2A ( \~AR1  ),
    .\3A ( \~AR2  ),
    .GND( 1'b0 ),
    .\4A ( INV_B_IN ),
    .\5A ( INV_A_IN ),
    .\6A ( \~AR3  ),
    .VCC( 1'b1 ),
    .\1Y ( AR0 ),
    .\2Y ( AR1 ),
    .\3Y ( AR2 ),
    .\4Y ( INV_B_OUT ),
    .\5Y ( s20 ),
    .\6Y ( AR3 )
  );
  assign EH = (s29 & s30 & INV_A_IN);
  assign EL = (s31 & s30 & INV_A_IN);
  assign OL_INSN = (s32 & INV_A_IN);
  assign LD_INSN = (s33 & s31 & s29 & s30);
  assign DEBUS[0] = DEBUS0;
  assign DEBUS[1] = DEBUS1;
  assign DEBUS[2] = DEBUS2;
  assign DEBUS[3] = DEBUS3;
  assign DEBUS[4] = DEBUS4;
  assign DEBUS[5] = DEBUS5;
  assign DEBUS[6] = DEBUS6;
  assign DEBUS[7] = DEBUS7;
  \7432  \7432_i7 (
    .\1A ( CLK1 ),
    .\1B ( INV_B_IN ),
    .\2A ( OL_INSN ),
    .\2B ( INV_B_OUT ),
    .GND( 1'b0 ),
    .\3A ( LD_INSN ),
    .\3B ( INV_B_OUT ),
    .\4A ( s21 ),
    .\4B ( JUMP_INSN ),
    .VCC( 1'b1 ),
    .\1Y ( \~WE_SRAM_temp  ),
    .\2Y ( \~OL  ),
    .\3Y ( \~LD  ),
    .\4Y ( PH )
  );
  assign s39[0] = \~WE_SRAM_temp ;
  assign s39[1] = \~WE_SRAM_temp ;
  assign s39[2] = \~WE_SRAM_temp ;
  assign s39[3] = \~WE_SRAM_temp ;
  assign s39[4] = \~WE_SRAM_temp ;
  assign s39[5] = \~WE_SRAM_temp ;
  assign s39[6] = \~WE_SRAM_temp ;
  assign s39[7] = \~WE_SRAM_temp ;
  // PC 0:3
  \74161  \74161_i8 (
    .\~CLR ( \~RESET  ),
    .CLK( CLK1 ),
    .A( BUS0 ),
    .B( BUS1 ),
    .C( BUS2 ),
    .D( BUS3 ),
    .ENP( 1'b1 ),
    .GND( 1'b0 ),
    .\~LD ( PL ),
    .ENT( 1'b1 ),
    .VCC( 1'b1 ),
    .QD( PC3 ),
    .QC( PC2 ),
    .QB( PC1 ),
    .QA( PC0 ),
    .RCO( s0 )
  );
  // PC 4:7
  \74161  \74161_i9 (
    .\~CLR ( \~RESET  ),
    .CLK( CLK1 ),
    .A( BUS4 ),
    .B( BUS5 ),
    .C( BUS6 ),
    .D( BUS7 ),
    .ENP( 1'b1 ),
    .GND( 1'b0 ),
    .\~LD ( PL ),
    .ENT( s0 ),
    .VCC( 1'b1 ),
    .QD( PC7 ),
    .QC( PC6 ),
    .QB( PC5 ),
    .QA( PC4 ),
    .RCO( s1 )
  );
  // PC 8:11
  \74161  \74161_i10 (
    .\~CLR ( \~RESET  ),
    .CLK( CLK1 ),
    .A( Y0 ),
    .B( Y1 ),
    .C( Y2 ),
    .D( Y3 ),
    .ENP( PL ),
    .GND( 1'b0 ),
    .\~LD ( PH ),
    .ENT( s1 ),
    .VCC( 1'b1 ),
    .QD( PC11 ),
    .QC( PC10 ),
    .QB( PC9 ),
    .QA( PC8 ),
    .RCO( s2 )
  );
  // PC 8:12
  \74161  \74161_i11 (
    .\~CLR ( \~RESET  ),
    .CLK( CLK1 ),
    .A( Y4 ),
    .B( Y5 ),
    .C( Y6 ),
    .D( Y7 ),
    .ENP( PL ),
    .GND( 1'b0 ),
    .\~LD ( PH ),
    .ENT( s2 ),
    .VCC( 1'b1 ),
    .QD( PC15 ),
    .QC( PC14 ),
    .QB( PC13 ),
    .QA( PC12 )
  );
  // Logic Unit 3
  \74153  \74153_i12 (
    .\1G ( 1'b0 ),
    .B( BUS3 ),
    .\1C3 ( AR3 ),
    .\1C2 ( AR2 ),
    .\1C1 ( AR1 ),
    .\1C0 ( AR0 ),
    .GND( 1'b0 ),
    .\2C0 ( 1'b0 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b0 ),
    .\2C3 ( 1'b1 ),
    .A( AC3 ),
    .\2G ( AL ),
    .VCC( 1'b1 ),
    .\1Y ( s3 ),
    .\2Y ( s4 )
  );
  \74283  \74283_i13 (
    .B2( s5 ),
    .A2( s6 ),
    .A1( s7 ),
    .B1( s8 ),
    .C0( AR0 ),
    .GND( 1'b0 ),
    .B4( s4 ),
    .A4( s3 ),
    .A3( s10 ),
    .B3( s11 ),
    .VCC( 1'b1 ),
    .S2( ALU1 ),
    .S1( ALU0 ),
    .C4( s9 ),
    .S4( ALU3 ),
    .S3( ALU2 )
  );
  // Logic Unit 2
  \74153  \74153_i14 (
    .\1G ( 1'b0 ),
    .B( BUS2 ),
    .\1C3 ( AR3 ),
    .\1C2 ( AR2 ),
    .\1C1 ( AR1 ),
    .\1C0 ( AR0 ),
    .GND( 1'b0 ),
    .\2C0 ( 1'b0 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b0 ),
    .\2C3 ( 1'b1 ),
    .A( AC2 ),
    .\2G ( AL ),
    .VCC( 1'b1 ),
    .\1Y ( s10 ),
    .\2Y ( s11 )
  );
  // Logic Unit 1
  \74153  \74153_i15 (
    .\1G ( 1'b0 ),
    .B( BUS1 ),
    .\1C3 ( AR3 ),
    .\1C2 ( AR2 ),
    .\1C1 ( AR1 ),
    .\1C0 ( AR0 ),
    .GND( 1'b0 ),
    .\2C0 ( 1'b0 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b0 ),
    .\2C3 ( 1'b1 ),
    .A( AC1 ),
    .\2G ( AL ),
    .VCC( 1'b1 ),
    .\1Y ( s6 ),
    .\2Y ( s5 )
  );
  // Logic Unit 0
  \74153  \74153_i16 (
    .\1G ( 1'b0 ),
    .B( BUS0 ),
    .\1C3 ( AR3 ),
    .\1C2 ( AR2 ),
    .\1C1 ( AR1 ),
    .\1C0 ( AR0 ),
    .GND( 1'b0 ),
    .\2C0 ( 1'b0 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b0 ),
    .\2C3 ( 1'b1 ),
    .A( AC0 ),
    .\2G ( AL ),
    .VCC( 1'b1 ),
    .\1Y ( s7 ),
    .\2Y ( s8 )
  );
  // Logic Unit 4
  \74153  \74153_i17 (
    .\1G ( AL ),
    .B( AC4 ),
    .\1C3 ( 1'b1 ),
    .\1C2 ( 1'b1 ),
    .\1C1 ( 1'b0 ),
    .\1C0 ( 1'b0 ),
    .GND( 1'b0 ),
    .\2C0 ( AR0 ),
    .\2C1 ( AR2 ),
    .\2C2 ( AR1 ),
    .\2C3 ( AR3 ),
    .A( BUS4 ),
    .\2G ( 1'b0 ),
    .VCC( 1'b1 ),
    .\1Y ( s14 ),
    .\2Y ( s15 )
  );
  // Logic Unit 5
  \74153  \74153_i18 (
    .\1G ( AL ),
    .B( AC5 ),
    .\1C3 ( 1'b1 ),
    .\1C2 ( 1'b1 ),
    .\1C1 ( 1'b0 ),
    .\1C0 ( 1'b0 ),
    .GND( 1'b0 ),
    .\2C0 ( AR0 ),
    .\2C1 ( AR2 ),
    .\2C2 ( AR1 ),
    .\2C3 ( AR3 ),
    .A( BUS5 ),
    .\2G ( 1'b0 ),
    .VCC( 1'b1 ),
    .\1Y ( s12 ),
    .\2Y ( s13 )
  );
  // Logic Unit 6
  \74153  \74153_i19 (
    .\1G ( AL ),
    .B( AC6 ),
    .\1C3 ( 1'b1 ),
    .\1C2 ( 1'b1 ),
    .\1C1 ( 1'b0 ),
    .\1C0 ( 1'b0 ),
    .GND( 1'b0 ),
    .\2C0 ( AR0 ),
    .\2C1 ( AR2 ),
    .\2C2 ( AR1 ),
    .\2C3 ( AR3 ),
    .A( BUS6 ),
    .\2G ( 1'b0 ),
    .VCC( 1'b1 ),
    .\1Y ( s19 ),
    .\2Y ( s18 )
  );
  // Logic Unit 7
  \74153  \74153_i20 (
    .\1G ( AL ),
    .B( AC7 ),
    .\1C3 ( 1'b1 ),
    .\1C2 ( 1'b1 ),
    .\1C1 ( 1'b0 ),
    .\1C0 ( 1'b0 ),
    .GND( 1'b0 ),
    .\2C0 ( AR0 ),
    .\2C1 ( AR2 ),
    .\2C2 ( AR1 ),
    .\2C3 ( AR3 ),
    .A( BUS7 ),
    .\2G ( 1'b0 ),
    .VCC( 1'b1 ),
    .\1Y ( s17 ),
    .\2Y ( s16 )
  );
  // Buffer/Inverter 2
  \7414  \7414_i21 (
    .\1A ( INV_C_IN ),
    .\2A ( \~AL  ),
    .\3A ( 1'b0 ),
    .GND( 1'b0 ),
    .\4A ( 1'b0 ),
    .\5A ( 1'b0 ),
    .\6A ( 1'b0 ),
    .VCC( 1'b1 ),
    .\1Y ( INV_C_OUT ),
    .\2Y ( AL )
  );
  // Condition Decoder
  \74153  \74153_i22 (
    .\1G ( JUMP_INSN ),
    .B( CO ),
    .\1C3 ( 1'b0 ),
    .\1C2 ( IR4 ),
    .\1C1 ( IR3 ),
    .\1C0 ( IR2 ),
    .GND( 1'b0 ),
    .\2C0 ( 1'b1 ),
    .\2C1 ( 1'b1 ),
    .\2C2 ( 1'b1 ),
    .\2C3 ( 1'b1 ),
    .A( AC7 ),
    .\2G ( 1'b1 ),
    .VCC( 1'b1 ),
    .\1Y ( INV_C_IN )
  );
  // Accumulator
  \74377  \74377_i23 (
    .\~E ( \~LD  ),
    .D0( ALU3 ),
    .D1( ALU2 ),
    .D2( ALU1 ),
    .D3( ALU0 ),
    .GND( 1'b0 ),
    .CLK( CLK2 ),
    .D4( ALU5 ),
    .D5( ALU4 ),
    .D6( ALU7 ),
    .D7( ALU6 ),
    .VCC( 1'b1 ),
    .Q0( AC3 ),
    .Q1( AC2 ),
    .Q2( AC1 ),
    .Q3( AC0 ),
    .Q4( AC5 ),
    .Q5( AC4 ),
    .Q6( AC7 ),
    .Q7( AC6 )
  );
  // X register high
  \74161  \74161_i24 (
    .\~CLR ( 1'b1 ),
    .CLK( CLK2 ),
    .A( ALU4 ),
    .B( ALU5 ),
    .C( ALU6 ),
    .D( ALU7 ),
    .ENP( s20 ),
    .GND( 1'b0 ),
    .\~LD ( \~XL  ),
    .ENT( s22 ),
    .VCC( 1'b1 ),
    .QD( X7 ),
    .QC( X6 ),
    .QB( X5 ),
    .QA( X4 )
  );
  // X register low
  \74161  \74161_i25 (
    .\~CLR ( 1'b1 ),
    .CLK( CLK2 ),
    .A( ALU0 ),
    .B( ALU1 ),
    .C( ALU2 ),
    .D( ALU3 ),
    .ENP( s20 ),
    .GND( 1'b0 ),
    .\~LD ( \~XL  ),
    .ENT( 1'b1 ),
    .VCC( 1'b1 ),
    .QD( X3 ),
    .QC( X2 ),
    .QB( X1 ),
    .QA( X0 ),
    .RCO( s22 )
  );
  // Y register
  \74377  \74377_i26 (
    .\~E ( \~YL  ),
    .D0( ALU0 ),
    .D1( ALU1 ),
    .D2( ALU2 ),
    .D3( ALU3 ),
    .GND( 1'b0 ),
    .CLK( CLK2 ),
    .D4( ALU7 ),
    .D5( ALU6 ),
    .D6( ALU5 ),
    .D7( ALU4 ),
    .VCC( 1'b1 ),
    .Q0( Y0 ),
    .Q1( Y1 ),
    .Q2( Y2 ),
    .Q3( Y3 ),
    .Q4( Y7 ),
    .Q5( Y6 ),
    .Q6( Y5 ),
    .Q7( Y4 )
  );
  // Output register
  \74377  \74377_i27 (
    .\~E ( \~OL  ),
    .D0( ALU3 ),
    .D1( ALU2 ),
    .D2( ALU1 ),
    .D3( ALU0 ),
    .GND( 1'b0 ),
    .CLK( CLK2 ),
    .D4( ALU4 ),
    .D5( ALU5 ),
    .D6( ALU6 ),
    .D7( ALU7 ),
    .VCC( 1'b1 ),
    .Q0( OUT3 ),
    .Q1( OUT2 ),
    .Q2( OUT1 ),
    .Q3( OUT0 ),
    .Q4( OUT4 ),
    .Q5( OUT5 ),
    .Q6( SER_PULSE_temp ),
    .Q7( SER_LATCH_temp )
  );
  \74157  \74157_i28 (
    .S( EL ),
    .A1( X4 ),
    .B1( D4 ),
    .A2( X5 ),
    .B2( D5 ),
    .GND( 1'b0 ),
    .B3( D6 ),
    .A3( X6 ),
    .B4( D7 ),
    .A4( X7 ),
    .G( 1'b0 ),
    .VCC( 1'b1 ),
    .Y1( SRAM_A4 ),
    .Y2( SRAM_A5 ),
    .Y3( SRAM_A6 ),
    .Y4( SRAM_A7 )
  );
  \74157  \74157_i29 (
    .S( EL ),
    .A1( X1 ),
    .B1( D1 ),
    .A2( X2 ),
    .B2( D2 ),
    .GND( 1'b0 ),
    .B3( D3 ),
    .A3( X3 ),
    .B4( D0 ),
    .A4( X0 ),
    .G( 1'b0 ),
    .VCC( 1'b1 ),
    .Y1( SRAM_A1 ),
    .Y2( SRAM_A2 ),
    .Y3( SRAM_A3 ),
    .Y4( SRAM_A0 )
  );
  \74157  \74157_i30 (
    .S( 1'b0 ),
    .A1( Y5 ),
    .B1( 1'b1 ),
    .A2( Y6 ),
    .B2( 1'b1 ),
    .GND( 1'b0 ),
    .B3( 1'b1 ),
    .A3( Y3 ),
    .B4( 1'b1 ),
    .A4( Y1 ),
    .G( EH ),
    .VCC( 1'b1 ),
    .Y1( SRAM_A13 ),
    .Y2( SRAM_A14 ),
    .Y3( SRAM_A11 ),
    .Y4( SRAM_A9 )
  );
  \74157  \74157_i31 (
    .S( 1'b0 ),
    .A1( Y0 ),
    .B1( 1'b1 ),
    .A2( Y7 ),
    .B2( 1'b1 ),
    .GND( 1'b0 ),
    .B3( 1'b1 ),
    .A3( Y2 ),
    .B4( 1'b1 ),
    .A4( Y4 ),
    .G( EH ),
    .VCC( 1'b1 ),
    .Y1( SRAM_A8 ),
    .Y2( SRAM_A15 ),
    .Y3( SRAM_A10 ),
    .Y4( SRAM_A12 )
  );
  // Game Controller Input
  \74595  \74595_i32 (
    .GND( 1'b0 ),
    .\~CLR ( 1'b1 ),
    .SCLK( SER_PULSE_temp ),
    .RCLK( SER_PULSE_temp ),
    .\~OE ( \~IE_temp  ),
    .SER( SER_DATA ),
    .VCC( 1'b1 ),
    .Q_B( IEBUS1 ),
    .Q_C( IEBUS2 ),
    .Q_D( IEBUS3 ),
    .Q_E( IEBUS4 ),
    .Q_F( IEBUS5 ),
    .Q_G( IEBUS6 ),
    .Q_H( IEBUS7 ),
    .Q_A( IEBUS0 )
  );
  assign PL = (PH & INV_C_OUT);
  assign s35 = ((DEBUS & ~ s34) | (Input_temp & ~ s36) | (AEBUS & ~ s37) | (SRAMDATAREAD & ~ s38));
  DriverInvBus #(
    .Bits(8)
  )
  DriverInvBus_i33 (
    .in( s40 ),
    .sel( \~WE_SRAM_temp  ),
    .out( SRAMDATAWRITE )
  );
  assign s40 = (BUSValue_temp & ~ s39);
  // BUS Gateway AC
  \74244fixed  \74244fixed_i34 (
    .\~1G ( \~AE  ),
    .\1A1 ( AC0 ),
    .\1A2 ( AC1 ),
    .\1A3 ( AC2 ),
    .\1A4 ( AC3 ),
    .GND( 1'b0 ),
    .\2A1 ( AC7 ),
    .\2A2 ( AC6 ),
    .\2A3 ( AC5 ),
    .\2A4 ( AC4 ),
    .\~2G ( \~AE  ),
    .VCC( 1'b1 ),
    .\2Y4 ( AEBUS4 ),
    .\2Y3 ( AEBUS5 ),
    .\2Y2 ( AEBUS6 ),
    .\2Y1 ( AEBUS7 ),
    .\1Y4 ( AEBUS3 ),
    .\1Y3 ( AEBUS2 ),
    .\1Y2 ( AEBUS1 ),
    .\1Y1 ( AEBUS0 )
  );
  assign ROMAddress[0] = PC0;
  assign ROMAddress[1] = PC1;
  assign ROMAddress[2] = PC2;
  assign ROMAddress[3] = PC3;
  assign ROMAddress[4] = PC4;
  assign ROMAddress[5] = PC5;
  assign ROMAddress[6] = PC6;
  assign ROMAddress[7] = PC7;
  assign ROMAddress[8] = PC8;
  assign ROMAddress[9] = PC9;
  assign ROMAddress[10] = PC10;
  assign ROMAddress[11] = PC11;
  assign ROMAddress[12] = PC12;
  assign ROMAddress[13] = PC13;
  assign ROMAddress[14] = PC14;
  assign ROMAddress[15] = PC15;
  \74283  \74283_i35 (
    .B2( s12 ),
    .A2( s13 ),
    .A1( s14 ),
    .B1( s15 ),
    .C0( s9 ),
    .GND( 1'b0 ),
    .B4( s16 ),
    .A4( s17 ),
    .A3( s18 ),
    .B3( s19 ),
    .VCC( 1'b1 ),
    .S2( ALU5 ),
    .S1( ALU4 ),
    .C4( CO ),
    .S4( ALU7 ),
    .S3( ALU6 )
  );
  \74273  \74273_i36 (
    .\~MR ( 1'b1 ),
    .D0( AC3 ),
    .D1( AC2 ),
    .D2( AC1 ),
    .D3( AC0 ),
    .GND( 1'b0 ),
    .CP( SER_PULSE_temp ),
    .D4( AC4 ),
    .D5( AC5 ),
    .D6( AC6 ),
    .D7( AC7 ),
    .VCC( 1'b1 ),
    .Q0( EXOUT0 ),
    .Q1( EXOUT1 ),
    .Q2( EXOUT2 ),
    .Q3( EXOUT3 ),
    .Q4( EXOUT4 ),
    .Q5( EXOUT5 ),
    .Q6( EXOUT6 ),
    .Q7( EXOUT7 )
  );
  assign VGA_R[0] = 1'b0;
  assign VGA_R[1] = 1'b0;
  assign VGA_R[2] = OUT0;
  assign VGA_R[3] = OUT1;
  assign VGA_G[0] = 1'b0;
  assign VGA_G[1] = 1'b0;
  assign VGA_G[2] = OUT2;
  assign VGA_G[3] = OUT3;
  assign VGA_B[0] = 1'b0;
  assign VGA_B[1] = 1'b0;
  assign VGA_B[2] = OUT4;
  assign VGA_B[3] = OUT5;
  assign RegAccu[0] = AC0;
  assign RegAccu[1] = AC1;
  assign RegAccu[2] = AC2;
  assign RegAccu[3] = AC3;
  assign RegAccu[4] = AC4;
  assign RegAccu[5] = AC5;
  assign RegAccu[6] = AC6;
  assign RegAccu[7] = AC7;
  assign RegX[0] = X0;
  assign RegX[1] = X1;
  assign RegX[2] = X2;
  assign RegX[3] = X3;
  assign RegX[4] = X4;
  assign RegX[5] = X5;
  assign RegX[6] = X6;
  assign RegX[7] = X7;
  assign RegY[0] = Y0;
  assign RegY[1] = Y1;
  assign RegY[2] = Y2;
  assign RegY[3] = Y3;
  assign RegY[4] = Y4;
  assign RegY[5] = Y5;
  assign RegY[6] = Y6;
  assign RegY[7] = Y7;
  assign RegOUT[0] = OUT0;
  assign RegOUT[1] = OUT1;
  assign RegOUT[2] = OUT2;
  assign RegOUT[3] = OUT3;
  assign RegOUT[4] = OUT4;
  assign RegOUT[5] = OUT5;
  assign RegOUT[6] = SER_PULSE_temp;
  assign RegOUT[7] = SER_LATCH_temp;
  assign SRAMAddress[0] = SRAM_A0;
  assign SRAMAddress[1] = SRAM_A1;
  assign SRAMAddress[2] = SRAM_A2;
  assign SRAMAddress[3] = SRAM_A3;
  assign SRAMAddress[4] = SRAM_A4;
  assign SRAMAddress[5] = SRAM_A5;
  assign SRAMAddress[6] = SRAM_A6;
  assign SRAMAddress[7] = SRAM_A7;
  assign SRAMAddress[8] = SRAM_A8;
  assign SRAMAddress[9] = SRAM_A9;
  assign SRAMAddress[10] = SRAM_A10;
  assign SRAMAddress[11] = SRAM_A11;
  assign SRAMAddress[12] = SRAM_A12;
  assign SRAMAddress[13] = SRAM_A13;
  assign SRAMAddress[14] = SRAM_A14;
  assign SRAMAddress[15] = SRAM_A15;
  assign Input_temp[0] = IEBUS0;
  assign Input_temp[1] = IEBUS1;
  assign Input_temp[2] = IEBUS2;
  assign Input_temp[3] = IEBUS3;
  assign Input_temp[4] = IEBUS4;
  assign Input_temp[5] = IEBUS5;
  assign Input_temp[6] = IEBUS6;
  assign Input_temp[7] = IEBUS7;
  assign AEBUS[0] = AEBUS0;
  assign AEBUS[1] = AEBUS1;
  assign AEBUS[2] = AEBUS2;
  assign AEBUS[3] = AEBUS3;
  assign AEBUS[4] = AEBUS4;
  assign AEBUS[5] = AEBUS5;
  assign AEBUS[6] = AEBUS6;
  assign AEBUS[7] = AEBUS7;
  assign BUS0 = s35[0];
  assign BUS1 = s35[1];
  assign BUS2 = s35[2];
  assign BUS3 = s35[3];
  assign BUS4 = s35[4];
  assign BUS5 = s35[5];
  assign BUS6 = s35[6];
  assign BUS7 = s35[7];
  assign BUSValue_temp[0] = BUS0;
  assign BUSValue_temp[1] = BUS1;
  assign BUSValue_temp[2] = BUS2;
  assign BUSValue_temp[3] = BUS3;
  assign BUSValue_temp[4] = BUS4;
  assign BUSValue_temp[5] = BUS5;
  assign BUSValue_temp[6] = BUS6;
  assign BUSValue_temp[7] = BUS7;
  assign ALUValue[0] = ALU0;
  assign ALUValue[1] = ALU1;
  assign ALUValue[2] = ALU2;
  assign ALUValue[3] = ALU3;
  assign ALUValue[4] = ALU4;
  assign ALUValue[5] = ALU5;
  assign ALUValue[6] = ALU6;
  assign ALUValue[7] = ALU7;
  assign EXOUT[0] = EXOUT0;
  assign EXOUT[1] = EXOUT1;
  assign EXOUT[2] = EXOUT2;
  assign EXOUT[3] = EXOUT3;
  assign EXOUT[4] = EXOUT4;
  assign EXOUT[5] = EXOUT5;
  assign EXOUT[6] = EXOUT6;
  assign EXOUT[7] = EXOUT7;
  assign \~OE_SRAM  = \~OE_SRAM_temp ;
  assign \~WE_SRAM  = \~WE_SRAM_temp ;
  assign VGA_HS = SER_PULSE_temp;
  assign VGA_VS = SER_LATCH_temp;
  assign SER_PULSE = SER_PULSE_temp;
  assign SER_LATCH = SER_LATCH_temp;
  assign BUSValue = BUSValue_temp;
  assign \Input  = Input_temp;
  assign \~IE  = \~IE_temp ;
endmodule
