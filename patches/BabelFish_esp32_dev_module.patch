Patch for BabelFish to support ESP32 Dev Module
https://github.com/kervinck/gigatron-rom.git commit 809b0fd834cb9ec2b219216722df4d567f65baeb

diff --git a/Utils/BabelFish/BabelFish.ino b/Utils/BabelFish/BabelFish.ino
index f146eb9e..d18d379a 100644
--- a/Utils/BabelFish/BabelFish.ino
+++ b/Utils/BabelFish/BabelFish.ino
@@ -40,6 +40,7 @@
 //      - Arduino Nano
 //      - Arduino/Genuino Micro
 //      - ATtiny85 (8 MHz)
+//      - ESP32 Dev Module
 
 /*----------------------------------------------------------------------+
  |                                                                      |
@@ -240,6 +241,27 @@
   #define hasSerial 0
 #endif
 
+#if defined (ARDUINO_ESP32_DEV)
+  #define platform "ESP32"
+  #define maxStorage 32256
+
+  // Pins for Gigatron (must be on PORTB)
+  #define gigatronDataPin  25
+  #define gigatronLatchPin 26
+  #define gigatronPulsePin 27
+  #define gigatronPinToBitMask digitalPinToBitMask
+
+  // Pins for Controller
+  #define gameControllerDataPin -1
+
+  // Pins for PS/2 keyboard (ESP32 Dev Module)
+  #define keyboardClockPin 16 // GPIO/IRQ
+  #define keyboardDataPin  17 // GPIO
+
+  // Link to PC/laptop
+  #define hasSerial 1
+#endif
+
 /*----------------------------------------------------------------------+
  |                                                                      |
  |      Built-in GT1 images                                             |
@@ -302,13 +324,6 @@ const struct { const byte *gt1; const char *name; } gt1Files[] = {
  |                                                                      |
  +----------------------------------------------------------------------*/
 
-/*
- *  Bit masks for pins
- */
-byte gigatronDataBit;
-byte gigatronLatchBit;
-byte gigatronPulseBit;
-
 /*
  *  Loader protocol
  */
@@ -364,13 +379,12 @@ extern const byte nrKeymaps; // From in PS2.ino
  */
 void setup()
 {
-  gigatronDataBit  = gigatronPinToBitMask(gigatronDataPin);
-  gigatronLatchBit = gigatronPinToBitMask(gigatronLatchPin);
-  gigatronPulseBit = gigatronPinToBitMask(gigatronPulsePin);
-
   // Enable output pin (pins are set to input by default)
-  PORTB |= gigatronDataBit; // Send 1 when idle
-  DDRB = gigatronDataBit;
+  pinMode(gigatronLatchPin, INPUT);
+  pinMode(gigatronPulsePin, INPUT);
+  pinMode(gigatronDataPin, OUTPUT);
+
+  digitalWrite(gigatronDataPin, HIGH);
 
   #if gameControllerDataPin >= 0
     pinMode(gameControllerDataPin, INPUT_PULLUP); // Force HIGH if disconnected
@@ -507,16 +521,19 @@ bool detectGigatron()
 
   // Sample the sync signals coming out of the controller port
   while (millis() < timeout) {
-    byte pinb = PINB; // capture SER_PULSE and SER_LATCH at the same time
-    T[(pinb & gigatronLatchBit ? 2 : 0) + (pinb & gigatronPulseBit ? 1 : 0)]++;
+    // TBD: capture SER_PULSE and SER_LATCH at the same time
+    T[(digitalRead(gigatronLatchPin) ? 2 : 0) + (digitalRead(gigatronPulsePin) ? 1 : 0)]++;
   }
-
+#if 0
   float S = T[0] + T[1] + T[2] + T[3] + .1;     // Avoid zero division (pedantic)
   float vSync = (T[0] + T[1]) / ( 8 * S / 521); // Adjusted vSync signal
   float hSync = (T[0] + T[2]) / (96 * S / 800); // Standard hSync signal
 
   // Check that vSync and hSync characteristics look normal
   return 0.95 <= vSync && vSync <= 1.25 && 0.90 <= hSync && hSync <= 1.10;
+#else
+  return (T[0] > 0) && (T[1] > 0) && (T[2] > 0) && (T[3] > 0);
+#endif
 }
 
 void sendEcho(char next, char last)
@@ -982,14 +999,18 @@ int nextSerial()
 
 static inline void critical()
 {
+#if 0
   forbidPs2();
   noInterrupts();
+  #endif
 }
 
 static inline void nonCritical()
 {
+  #if 0
   interrupts();
   allowPs2();
+  #endif
 }
 
 // Send a 1..256 byte code or data segment into the Gigatron by
@@ -1009,7 +1030,7 @@ void sendGt1Segment(word address, int len)
 
   // Wait for vPulse to start so we're 100% sure to skip one frame and
   // the checksum resets on the other side. (This is a bit pedantic)
-  while (PINB & gigatronLatchBit) // ~160 us
+  while (digitalRead(gigatronLatchPin)) // ~160 us
     ;
 }
 
@@ -1029,11 +1050,13 @@ void sendController(byte value, int n)
   // Send controller code for n frames
   // E.g. 4 frames = 3/60s = ~50 ms
   critical();
-  for (int i=0; i<n; i++)
+  waitVSync();
+  for (int i=0; i<n; i++) {
     sendFirstByte(value);
+  }
   nonCritical();
 
-  PORTB |= gigatronDataBit; // Send 1 when idle
+  digitalWrite(gigatronDataPin, HIGH); // Send 1 when idle
 }
 
 void resetChecksum()
@@ -1067,31 +1090,31 @@ void sendFrame(byte firstByte, byte len, word address, byte message[])
   byte lastByte = -checksum;   // Checksum must come out as 0
   sendBits(lastByte, 8);
   checksum = lastByte;         // Concatenate checksums
-  PORTB |= gigatronDataBit;    // Send 1 when idle
+  digitalWrite(gigatronDataPin, HIGH);    // Send 1 when idle
 }
 
 void sendFirstByte(byte value)
 {
   // Wait vertical sync NEGATIVE edge to sync with loader
-  while (~PINB & gigatronLatchBit) // Ensure vSync is HIGH first
+  while (!digitalRead(gigatronLatchPin)) // Ensure vSync is HIGH first
     ;
 
   // Send first bit in advance
   if (value & 128)
-    PORTB |= gigatronDataBit;
+    digitalWrite(gigatronDataPin, HIGH);
   else
-    PORTB &= ~gigatronDataBit;
+    digitalWrite(gigatronDataPin, LOW);
 
-  while (PINB & gigatronLatchBit) // Then wait for vSync to drop
+  while (digitalRead(gigatronLatchPin)) // Then wait for vSync to drop
     ;
 
   // Wait for bit transfer at horizontal sync RISING edge. As this is at
   // the end of a short (3.8 us) pulse following VERY shortly (0.64us) after
   // vSync drop, this timing is tight. That is the reason that interrupts
   // must be disabled on the microcontroller (and why 1 MHz isn't enough).
-  while (PINB & gigatronPulseBit) // Ensure hSync is LOW first
+  while (digitalRead(gigatronPulsePin)) // Ensure hSync is LOW first
     ;
-  while (~PINB & gigatronPulseBit) // Then wait for hSync to rise
+  while (!digitalRead(gigatronPulsePin)) // Then wait for hSync to rise
     ;
 
   // Send remaining bits
@@ -1104,14 +1127,14 @@ void sendBits(byte value, byte n)
   for (byte bit=1<<(n-1); bit; bit>>=1) {
     // Send next bit
     if (value & bit)
-      PORTB |= gigatronDataBit;
+      digitalWrite(gigatronDataPin, HIGH);
     else
-      PORTB &= ~gigatronDataBit;
+      digitalWrite(gigatronDataPin, LOW);
 
     // Wait for bit transfer at horizontal sync POSITIVE edge.
-    while (PINB & gigatronPulseBit)  // Ensure hSync is LOW first
+    while (digitalRead(gigatronPulsePin))  // Ensure hSync is LOW first
       ;
-    while (~PINB & gigatronPulseBit) // Then wait for hSync to rise
+    while (!digitalRead(gigatronPulsePin)) // Then wait for hSync to rise
       ;
   }
   checksum += value;
@@ -1153,22 +1176,21 @@ byte waitVSync()
 
   // Wait vertical sync NEGATIVE edge
 
-  while (~PINB & gigatronLatchBit) // Ensure vSync is HIGH first
+  while (!digitalRead(gigatronLatchPin)) // Ensure vSync is HIGH first
     if (!--timeout)
       return 0;
-
-  while (PINB & gigatronLatchBit) // Then wait for vSync to drop
+  while (digitalRead(gigatronLatchPin)) // Then wait for vSync to drop
     if (!--timeout)
       return 0;
 
   // Now count horizontal sync POSITIVE edges
   byte count = 0;
   for (;;) {
-    while (PINB & gigatronPulseBit)  // Ensure hSync is LOW first
+    while (digitalRead(gigatronPulsePin))  // Ensure hSync is LOW first
       ;
-    if (PINB & gigatronLatchBit)     // Not in vPulse anymore
+    if (digitalRead(gigatronLatchPin))     // Not in vPulse anymore
       break;
-    while (~PINB & gigatronPulseBit) // Then wait for hSync to rise
+    while (!digitalRead(gigatronPulsePin)) // Then wait for hSync to rise
       ;
     count += 1;
   }
diff --git a/Utils/BabelFish/PS2.ino b/Utils/BabelFish/PS2.ino
index d787ffa2..847dc377 100644
--- a/Utils/BabelFish/PS2.ino
+++ b/Utils/BabelFish/PS2.ino
@@ -73,6 +73,12 @@
 
 #define CTRLALTDEL     (255 ^ buttonStart)
 
+#if defined (ARDUINO_ESP32_DEV)
+inline word max(word a, int b) {
+    return (a > b) ? a : b;
+}
+#endif
+
 /*
  *  Keyboard layout mapping
  */
@@ -500,12 +506,14 @@ void allowPs2()
   _n = 11;                       // Consider previous bits lost
 }
 
+#if 0
 // Pull clock line LOW to signal that we're not ready to receive
 void forbidPs2()
 {
   digitalWrite(keyboardClockPin, LOW);
   pinMode(keyboardClockPin, OUTPUT);
 }
+#endif
 
 // Read next byte from incoming PS/2 buffer, or 0 when empty
 static byte readPs2Buffer()
@@ -540,7 +548,7 @@ byte keyboard_getState()
       case 0xaa: // BAT ok
         #define oddParity(x) ((1 ^ x ^ (x>>1) ^ (x>>2) ^ (x>>3) ^ (x>>4) ^ (x>>5) ^ (x>>6) ^ (x>>7)) & 1)
         #define code(x) ((1 << 10) | (oddParity(x) << 9) | ((x) << 1))
-        keyboard_send(code(0xf4)); // Enable (fixes Walter's PERIBOARD-409)
+        // TBD: keyboard_send(code(0xf4)); // Enable (fixes Walter's PERIBOARD-409)
         continue;
     }
 
@@ -656,6 +664,7 @@ byte fnKey(byte key)
   return (PS2_F1 <= key && key <= PS2_F12) ? (key & 15) : 0;
 }
 
+#if 0
 // 'code' must include start, data, parity and stop bits
 void keyboard_send(word code)
 {
@@ -708,3 +717,4 @@ void keyboard_send(word code)
   while (digitalRead(keyboardClockPin) == 0 || digitalRead(keyboardDataPin) == 0)
     ;
 }
+#endif
diff --git a/Utils/sendFile.py b/Utils/sendFile.py
index 1118140e..f594090b 100755
--- a/Utils/sendFile.py
+++ b/Utils/sendFile.py
@@ -167,9 +167,13 @@ if isGt1 or isGtb:
   print('Resetting Gigatron')
   sendCommand('R')
 
+  sleep(2)
+
   print('Starting Loader')
   sendCommand('L')
 
+  sleep(2)
+
 if isGt1:
   print('Sending program %s' % repr(args.filename))
   sendGt1(fp)
@@ -177,7 +181,7 @@ if isGt1:
 if isGtb:
   print('Loading Tiny BASIC')
   sendCommand('P')              # Load BASIC from BabelFish PROGMEM
-  sleep(2)                      # Startup takes a while on 64K
+  sleep(4)                      # Startup takes a while on 64K
   args.truncate = 25            # Line limit
 
 if not isGt1:
